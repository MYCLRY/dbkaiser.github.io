<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>KaiTu</title>
        <description>KaiTu - Dong Bo</description>
        <link>http://dbkaiser.github.io</link>
        <link>http://dbkaiser.github.io</link>
        <lastBuildDate>2013-09-23T17:37:04+08:00</lastBuildDate>
        <pubDate>2013-09-23T17:37:04+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>el get方便管理emacs插件</title>
                <description>&lt;h1 id='el_get_'&gt;el get 介绍&lt;/h1&gt;

&lt;p&gt;el-get是Emacs现下最受欢迎的包安装管理工具。由于Emacs一直以来虽然具有强大的扩展能力，但是第三方插件始终没有个统一的安装方法。往往用户需要编写或者粘贴大量的elisp代码到.emacs文件或者init.el文件中。而且升级往往也是比较麻烦的事。el-get就是这样一个肩负起Emacs“一键安装”，“简单部署”大任的利器。el-get就如同著名的debian package管理工具apt-get一样，简单易用。让你的emacs配置需求大大降低。进而可以专注于享受emacs给你带来的快乐。&lt;/p&gt;

&lt;h1 id='id12'&gt;安装&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;联网，并且安装需要的外部工具： git\ cvs\ install-info 等等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2. 安装&lt;/p&gt;

&lt;h2 id='id13'&gt;懒加载安装&lt;/h2&gt;

&lt;p&gt;懒加载的意思就是说平时你不想乱动你的emacs。需要el-get运行时可以直接在*scratch*的buffer里面运行：&lt;/p&gt;

&lt;h4 id='id14'&gt;稳定版&lt;/h4&gt;

&lt;p&gt;稳定版就是粘贴下面的代码到你的buffer里面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; So the idea is that you copy/paste this code into your *scratch* buffer,
;; hit C-j, and you have a working el-get.
(url-retrieve
&amp;quot;https://raw.github.com/dimitri/el-get/master/el-get-install.el&amp;quot;
(lambda (s)
   (goto-char (point-max))
      (eval-print-last-sexp)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行&lt;code&gt;eval-buffer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一小会儿后emacs会有通知相应，这样就可以运行el-get了&lt;/p&gt;

&lt;h4 id='id15'&gt;开发版&lt;/h4&gt;

&lt;p&gt;开发版也差不多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; So the idea is that you copy/paste this code into your *scratch* buffer,
;; hit C-j, and you have a working developper edition of el-get.
(url-retrieve
  &amp;quot;https://raw.github.com/dimitri/el-get/master/el-get-install.el&amp;quot;
  (lambda (s)
    (let (el-get-master-branch)
      (goto-char (point-max))
        (eval-print-last-sexp))))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行之后实际上是将git上的工程clone到本地默认路径是： &lt;code&gt;~/.emacs.d/el-get/el-get&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id='id16'&gt;自动安装&lt;/h2&gt;

&lt;p&gt;自动安装可以在emacs启动运行时加载&lt;code&gt;el-get&lt;/code&gt;，这样你可以随时运行了。 可以第一次运行上面的“懒安装”，将el-get下载下来之后尝尝鲜。后买就可以开始配置你的emacs启动文件了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(add-to-list &amp;#39;load-path &amp;quot;~/.emacs.d/el-get/el-get&amp;quot;)
(unless (require &amp;#39;el-get nil &amp;#39;noerror)
(with-current-buffer
(url-retrieve-synchronously
	       &amp;quot;https://raw.github.com/dimitri/el-get/master/el-get-install.el&amp;quot;)
        (goto-char (point-max))
		(eval-print-last-sexp)))
(add-to-list &amp;#39;el-get-recipe-path &amp;quot;~/.emacs.d/el-get-user/recipes&amp;quot;)
(el-get &amp;#39;sync)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面，首先是加载本地的el-get。如果加载失败，则从github上下载。 之后将&lt;code&gt;el-get-user&lt;/code&gt;作为用户的recipes目录。用户可以自己定义“recipe”。即相当于apt-get 中的ppa。 最后&lt;code&gt;&amp;#39;sync&lt;/code&gt;表示同步最新的版本。&lt;/p&gt;

&lt;h1 id='id17'&gt;使用&lt;/h1&gt;

&lt;p&gt;由于el-get是异步更新的。包的下载并不会影响用户的其他工作。这点非常爽。emacs2.4里面的package如果网络链接有问题，其他事情也就干不了了。&lt;/p&gt;

&lt;p&gt;几个最常用的命令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;el-get-list-packages&lt;/code&gt; 列举可安装的项及简介&lt;/li&gt;

&lt;li&gt;&lt;code&gt;el-get-install&lt;/code&gt; 安装指定项&lt;/li&gt;

&lt;li&gt;&lt;code&gt;el-get-remove&lt;/code&gt; 卸载&lt;/li&gt;

&lt;li&gt;&lt;code&gt;el-get-emacswiki-refresh&lt;/code&gt; 从emacswiki上获得可安装的列表，这里货相当多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;el-get-install&lt;/code&gt;的功能是将远程包下载到本地。依然需要你在emacs启动文件中进行&lt;code&gt;require&lt;/code&gt;等的配置。&lt;/p&gt;

&lt;h2 id='id18'&gt;其他帮助&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安装后就可以在你emacs info中&lt;code&gt;C-h i&lt;/code&gt;查看到el-get的帮助文档。&lt;/li&gt;

&lt;li&gt;可以参考&lt;a href='http://wikemacs.org/index.php/El-get'&gt;官方安装指南&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;可以参考官方的&lt;a href='https://github.com/dimitri/el-get/blob/master/README.md'&gt;README文件&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;可以参考&lt;a href='http://google.com'&gt;我的配置文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
                <link>http://dbkaiser.github.io/Emacs/2013/09/23/el-getemacs</link>
                <guid>http://dbkaiser.github.io/Emacs/2013/09/23/el-getemacs</guid>
                <pubDate>2013-09-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Emacs下irc聊天以及浏览网页、收发邮件</title>
                <description>&lt;h1 id='ircerc'&gt;IRC介绍以及ERC安装&lt;/h1&gt;

&lt;p&gt;IRC: Internet Realtime Client???&lt;/p&gt;

&lt;p&gt;IRC是一种十分古老的网络聊天室，可以上溯到上&lt;a href='http://www.google.com'&gt;世纪80年代&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id='id10'&gt;常用命令&lt;/h1&gt;

&lt;h1 id='id11'&gt;常用网站&lt;/h1&gt;</description>
                <link>http://dbkaiser.github.io/Emacs/2013/09/16/emacsirc</link>
                <guid>http://dbkaiser.github.io/Emacs/2013/09/16/emacsirc</guid>
                <pubDate>2013-09-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>emacs debug c\c++工程</title>
                <description>&lt;h2 id='emacs_debug_cc'&gt;emacs debug c\c++工程&lt;/h2&gt;

&lt;h1 id='emacs_debug_'&gt;emacs debug 记录&lt;/h1&gt;

&lt;p&gt;emacs可以很方便和gdb结合。进行debug和编译。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;ede mode&lt;/code&gt;下可以通过&lt;code&gt;M-x ede-new RET&lt;/code&gt;来自动创建make文件和工程信息。&lt;/p&gt;

&lt;p&gt;这里ede的工程需要你输入工程类别：Make/ AutoMake/ direct AutoMake/ Simple&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Make 类别会创建一个下工程文件&lt;code&gt;Project.ede&lt;/code&gt;以及自动生成Makefile。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Automake: 这个与上面Make的不同指出就是除了上面两个文件之外还会生成&lt;code&gt;Makefile.am&lt;/code&gt;。以及make前后的配置的&lt;code&gt;configure.am&lt;/code&gt;脚本。如需要还会生成其他必要文件。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;direct Automatke: 这个ede会从Automake的文件中获取相关参数，建造工程。这种方式是不能通过&lt;code&gt;M-x ede-new RET&lt;/code&gt;来创建的。而是访问已有Automake文件的工程自动出发的。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Simple 这种就是一个简单的工程。可以另Semantic等emacs包来分析工程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详细信息可以通过info文档中ede章节来学习。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;M-x compile&lt;/code&gt;进行编译。&lt;code&gt;M-x gdb&lt;/code&gt;进行调试。&lt;/p&gt;

&lt;p&gt;进入debug后相当与一个emacs整合的gdb。gdb命令依然适用。不过可以在另一个窗口直接查看当前运行到的代码以及console输出。亦可以通过光标移动到指定位置设置断点。快捷键为：&lt;code&gt;C-x SPC&lt;/code&gt;。&lt;a href='http://wenku.baidu.com/view/fec27500b52acfc789ebc903.html'&gt;这篇文章&lt;/a&gt;列举了主要有用的快捷键。&lt;/p&gt;

&lt;h1 id='debug_'&gt;debug 命令&lt;/h1&gt;

&lt;h2 id='gdb'&gt;这里再记录几个有效的gdb命令：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;p 打印&lt;/li&gt;

&lt;li&gt;n 下一步&lt;/li&gt;

&lt;li&gt;s 跳入&lt;/li&gt;

&lt;li&gt;finish 跳出&lt;/li&gt;

&lt;li&gt;r 启动&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='id9'&gt;怎样打印数组呢？&lt;/h2&gt;

&lt;p&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p *varible@lenght&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://dbkaiser.github.io/Emacs/2013/09/13/new-post</link>
                <guid>http://dbkaiser.github.io/Emacs/2013/09/13/new-post</guid>
                <pubDate>2013-09-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jekyll 初体验</title>
                <description>&lt;h2 id='id8'&gt;小坑&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;jekyll利用率yaml？？的解析作为头部解析，优点是简介明了。但是缺点是解析时需要多多注意。如&lt;code&gt;\&lt;/code&gt;是需要转意字符转意的，也就是要写成&lt;code&gt;\\&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;其次类别是不支持中文字符的。我不确定是不是因为操作系统的原因。在linux下面写的中文字符做分类是不能被jekyll正确解析的。&lt;/li&gt;

&lt;li&gt;在markdown中，对于list，如果有没有英文字母，则不能正确转意。比如&lt;code&gt;- 这一行没有英文字母将不会转意&lt;/code&gt;这可能是当前jekyll的一个bug&lt;/li&gt;
&lt;/ul&gt;</description>
                <link>http://dbkaiser.github.io/Blog/2013/09/13/jekyll-</link>
                <guid>http://dbkaiser.github.io/Blog/2013/09/13/jekyll-</guid>
                <pubDate>2013-09-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>github下面建立blog</title>
                <description>&lt;h2 id='id6'&gt;前言&lt;/h2&gt;

&lt;p&gt;新浪blog非常好。可以通过xrpc方式进行发布blog。用我用chrome的插件scribefire就可以很方便的用markdown来写blog。但是用emacs的org2blog插件确不能很好的兼容。org2blog可以支持wordpress。但是国内几个网站的blog xrpc就不那么支持了。我又尝试了用几大网站的云app建wordpress。&lt;a href='http://developer.baidu.com/bae/'&gt;百度云&lt;/a&gt;需要大量特有的api修改。不能和原生wordpress结合。而官网发布的wordpress不仅版本较老，而且貌似不是很稳定，我的blog在几天之后访问出现了问题。&lt;a href='http://sae.sina.com.cn/'&gt;新浪云&lt;/a&gt;不免费，还得花钱。不符合我的屌丝习惯。。。&lt;a href='http://appengine.google.com/'&gt;gae&lt;/a&gt;对wordpress支持很好，可以无缝安装部署。但是mysql的存储是收费的。相当与要写blog就要收费。也没戏。剩下那些国外的那些blog就是墙的问题了。突然看到别人的blog写了后缀是github。才发现github现在已经支持了个人网站的发布。好欣喜啊。终于可以方便的用emacs写blog了。&lt;/p&gt;

&lt;p&gt;这里的文字都源于&lt;a href='https://help.github.com/articles/creating-pages-with-the-automatic-generator'&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id='id7'&gt;起步&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;建立你自己的页面repo：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以用户为例，你的新repo的名字必须是：&lt;code&gt;username.github.io&lt;/code&gt;，这里面username必须是你的用户名。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击repo的setting:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt='setting' src='https://github-images.s3.amazonaws.com/help/repo-actions-settings.png' /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击Automatic Page Generator:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt='apg' src='https://github-images.s3.amazonaws.com/help/pages-automatic-page-generator.png' /&gt;&lt;/p&gt;

&lt;p&gt;这样你就可以编辑你在github上第一个页面的内容了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编辑你的页面并配置你的主题(Theme):&lt;/p&gt;

&lt;p&gt;&lt;img alt='edit' src='https://github-images.s3.amazonaws.com/blog/2012/page-generator-picker.png' /&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;发布(Publish)：&lt;/p&gt;

&lt;p&gt;&lt;img alt='publish' src='https://github-images.s3.amazonaws.com/blog/2012/page-generator-publish.png' /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;点击publish&lt;/p&gt;

&lt;p&gt;好了。 这样你页面可以在10分钟之后通过http://username.github.io来访问，username是你的用户名。这是一个最基本的静态页面网站。你可以通过github的repo来修改，编辑内容。下面我们会学习怎么用&lt;a href='http://jekyllbootstrap.com/'&gt;Jekyll&lt;/a&gt; 来建立自己的blog。&lt;/p&gt;

&lt;p&gt;&lt;a href='http://erjjones.github.io/blog/How-I-built-my-blog-in-one-day/'&gt;这篇文章&lt;/a&gt;提供了更多丰富的选择。&lt;/p&gt;</description>
                <link>http://dbkaiser.github.io/Blog/2013/09/10/githubblog</link>
                <guid>http://dbkaiser.github.io/Blog/2013/09/10/githubblog</guid>
                <pubDate>2013-09-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>利用ssh父链接免密码登录其他机器</title>
                <description>&lt;h1 id='ssh_master_control'&gt;SSH Master Control&lt;/h1&gt;

&lt;p&gt;ssh其实可以保存利用父链接，将多个会话共享同一个ssh链接，这样再次登录同一ssh账户后可以不需要再次密码认证。在windows中的securecrt具有此种功能。即克隆会话。在linux下面则可以更直接的利用openssh的配置进行处理。&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.cyberciti.biz/faq/linux-unix-reuse-openssh-connection/'&gt;这篇文章&lt;/a&gt;很好的诠释了openssh共享父链接的方法和原理。或者叫做复用链接（ControlMaster）的方法。&lt;/p&gt;

&lt;h1 id='screen'&gt;Screen&lt;/h1&gt;

&lt;p&gt;另外学习了一下screen的用法，又发现了linux下面的一个神器。&lt;a href='http://wiki.ubuntu.org.cn/index.php?title%3DGNUScreen&amp;amp;variant%3Dzh-hans'&gt;这篇文章&lt;/a&gt;完美的诠释了screen的入门命令和超级功能。 这里粘贴一点：&lt;/p&gt;

&lt;p&gt;一言以蔽之，screen是个终端的多路复用器。借助screen，你可以在单个终端内运行任意数量的基于终端的应用程序，如交互的命令shell，基于curses的应用程序，文本编辑器等等。做到这点的渴望正是大多数人迷上screen的原因。过去我登录到系统后，常常得打开六七个终端模拟器：一个用来读邮件，一个用来编辑代码，一个来编译代码，一个用来阅读新闻，一个用作登录web主机的shell，等等。现如今，我只要启动一个终端模拟器，然后在其中运行screen。Ok，一切搞定。&lt;/p&gt;

&lt;p&gt;screen另一个很酷的主要特性是它能使运行着的程序脱离终端模拟器。也就是说即使你不小心关闭终端模拟器，screen也能让程序继续运行；甚至在你注销之后，它也能让程序在你下次登录后从上次中断处继续执行。也就意味着，所谓的“会话”——你在期间运行大量终端程序——是个自由流动的实体，你可以把它绑定到任意处的任意终端上，甚至根本不绑定，只要你愿意。&lt;/p&gt;

&lt;p&gt;注意，在拷贝模式下，需要用空格进行标记开始和结束。拷贝模式下的命令和vi命令很多相一致，详细可以参考&lt;a href='http://my.oschina.net/u/1012289/blog/119864'&gt;这篇文章&lt;/a&gt; 。&lt;/p&gt;</description>
                <link>http://dbkaiser.github.io/Linux/2013/08/27/ssh</link>
                <guid>http://dbkaiser.github.io/Linux/2013/08/27/ssh</guid>
                <pubDate>2013-08-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>计算机学习的一点感悟</title>
                <description>&lt;h2 id='id5'&gt;随手写&lt;/h2&gt;

&lt;p&gt;记得大一的时候。做计算机编程的c语言课设。题目是连连看消除的小游戏。用c语言实现。包括gui、算法等等等等。别看游戏很小。发挥的空间确很大。比如游戏可以即用鼠标控制，也用键盘控制，可以用何种方式展现，甚至可以增加ai等等。由于没有类库、没有framework。一切都是最基础的从头开始。我做的和大多数人一样，就是找到制定的展示方法，然后将核心算法实现。优化上应该主要就是让展示更美观，让系统更稳定等等了。更厉害的一位同学则是完成了鼠标和键盘共同控制游戏（我的控制只有鼠标），令我羡慕不已。不过另外一位同学，我们叫他同学t吧。我碰到这位同学t讨论各自的程序的时候，他确在告诉我说他正在研究显示驱动的实现，就是那种很底层的，包含部分汇编的代码。我就很费解，问他：这对你完成这个课设实现有帮助么？他说：凡事都要明白为什么嘛。我就想，与其有这个时间还不如多放写精力在界面设计上，让你的课设更美观更稳定。后来成绩出来了，我得了97。同学t得了98。对这一分的差距，我不以为然，他付出很多辛苦、很多研究。我肯定承认他会做得比我好，但是有必要吗？这位同学现在在美国读数学系的博士。他说他读计算机是选错方向了，在本科中他就辅修了数学系。他基本没怎么准备英语考试，本科发表了好几篇数学论文。直接“保送”过去了。现在想想，这就是那一分差距中包含的内容。&lt;/p&gt;

&lt;p&gt;后来到了工作中，我感觉我凭着动手和小聪明还是沾了不少光。在计算机职业中，动手能力很重要。上手快，学习快，很重要。但是另外一个问题让我日益感觉到了，那一分的重要。李彦宏提了个口号，叫做事要做到极致，开始并不觉得，等和一些资深的员工合作时才发现，他们的“极致”的思想。一些事当然是可以通过临时抱抱佛脚快速完成。但后面别人的各种challenge也会接踵而至。有些事情确实通过google就可以解决了。但是可能下次、下下次还需要google。感觉上一次两次好像很快，但是没有积累，后面的问题和坑才越来越多。其实真的浪费了很多时间和经验。做到极致，就是需要知其然，更知其所以然。极致，就是厚积薄发，未雨绸缪。极致，就是那一分的差距。&lt;/p&gt;</description>
                <link>http://dbkaiser.github.io/work/2013/08/27/</link>
                <guid>http://dbkaiser.github.io/work/2013/08/</guid>
                <pubDate>2013-08-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>IOS 的线程编程</title>
                <description>&lt;h2 id='iosdelegate'&gt;IOS下得delegate机制&lt;/h2&gt;

&lt;p&gt;尝试了几天IOS编程，觉得比较有特色的是他的线程编程易用性。其实和安卓中的界面线程特殊性相同，IOS也对线程编程做了很多工作。使得IOS下面的线程编写非常简单。&lt;/p&gt;

&lt;h1 id='id2'&gt;线程编程&lt;/h1&gt;

&lt;p&gt;//TODO 增加安卓主线程限制。&lt;/p&gt;

&lt;p&gt;IOS 相较于安卓的线程编程提供了很易用的api，但却没有关于“主线程”的种种&lt;a href=''&gt;限制&lt;/a&gt;。IOS中主线程仍可以进行网络通信，甚至等待。但是我们写程序时候依然应注意，应在子线程中进行网络通信。&lt;/p&gt;

&lt;h2 id='id3'&gt;启动线程&lt;/h2&gt;

&lt;p&gt;有三种启动线程的方式： - 直接调用&lt;/p&gt;

&lt;p&gt;直接调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[myObj performSelectorInBackground:@selector(myThreadMainMethod) withObject:nil];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式直接将selector（被调用的线程线程程序）放入“后台线程”。&lt;/p&gt;

&lt;p&gt;需要&lt;em&gt;注意&lt;/em&gt;的是后台线程只有&lt;em&gt;单独线程&lt;/em&gt;。两次调用此函数，如果前一个函数没有运行完，后面不会运行。&lt;/p&gt;

&lt;p&gt;在xcode中（亦可能是ios版本的问题），有可能@selector不能被解析导致编译不过去。可以通过：来运行时加载selector。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//TODO dynamic add selector&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;NSThread调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种调用更加灵活，可以配置单独的子线程运行程序。&lt;/p&gt;

&lt;h2 id='id4'&gt;线程通信&lt;/h2&gt;

&lt;p&gt;IOS编程是严格依照MVC模式进行的。&lt;/p&gt;</description>
                <link>http://dbkaiser.github.io/IOS/2013/08/16/ios-</link>
                <guid>http://dbkaiser.github.io/IOS/2013/08/16/ios-</guid>
                <pubDate>2013-08-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu 13.04 下的一些软件配置：MPlayer,Anyconnect,VMWare, Oracle Java</title>
                <description>&lt;h1 id='id1'&gt;前言&lt;/h1&gt;

&lt;p&gt;Ubuntu 13.04下有些软件和之前的版本配置有所不同，其实是更好用了，但是网上的老版本教程会不管用。这里记录一下：&lt;/p&gt;

&lt;h1 id='vmware_toolubuntu_13'&gt;VMWare tool在Ubuntu 13下安装失败的问题&lt;/h1&gt;

&lt;p&gt;vmware player 非常好用，在任何操作系统下都可以简单完成虚拟系统的安装。不过，在Ubuntu13下安装完xp系统后在安装vmware tool时确没有那么顺利。不是自动升级完成的。这里就可以参考&lt;a href='https://communities.vmware.com/thread/447865?start%3D0&amp;amp;tstart%3D0'&gt;这篇文章&lt;/a&gt;。 需要手动下载vmware tool进行安装。&lt;/p&gt;

&lt;h1 id='cisco_anyconnect_ubuntu_1304'&gt;Cisco Anyconnect 在Ubuntu 1304下面的使用&lt;/h1&gt;

&lt;p&gt;很多公司登录vpn都是用的Cisco Anyconnect。非常好用，且各个平台都很齐全。但是在Ubuntu1304下面安装之后确发现无法正常连接。总出出现“cannot connect to gateway”的错误。于是谷歌一下。发现了&lt;a href='https://supportforums.cisco.com/thread/2226093'&gt;这篇文章&lt;/a&gt;。 Ubuntu下面一个开源工具： openconnect就可以适配的完成这个工作。无需另行安装。&lt;/p&gt;

&lt;p&gt;只需运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install network-manager-openconnect-gnome&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后直接在屏幕右上角上面的vpn connection中选择你要链接的公司vpn网址就ok了。很方便的！&lt;/p&gt;

&lt;h1 id='ubuntu_mplayer'&gt;Ubuntu 下面MPlayer的中文字体&lt;/h1&gt;

&lt;p&gt;这个真是折腾了好久，可能是因为网上的同学们使用的版本不一致，按照各种各样的说法都不能展示中文字幕。最后发现是这样的：（我这里说明的是命令行的，MPlayer, gmplayer可以参考，但没有实践）&lt;/p&gt;

&lt;p&gt;我这里使用的是Ubuntu1304版本&lt;/p&gt;

&lt;p&gt;MPlayer 版本：&lt;/p&gt;

&lt;p&gt;如很多教程所说： 需要在~/.mplayer/config中设定参数只要两项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; subcp=cp936
 subfont=&amp;quot;AR PL UKai CN&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里很多教程都是说指向ttf或ttc的绝对路径。但是我这样试都是失败的。只有横线留下。这里我用的是font的名称。可以通过&lt;code&gt;gnome-font-viewer&lt;/code&gt;来查看。&lt;/p&gt;

&lt;p&gt;这里最主要的问题就是这个subfont。一直没找对路，一旦subfont对了以后，后面都还是很智能的。subcp是选择语言种类，这里你填utf-8\gbk\cp936都可以，如果是cp936的话，他甚至可以自动识别字母的编码是gbk还是utf-8，不需要用iconv手工转换。教程太多了也麻烦。&lt;/p&gt;

&lt;h1 id='ubuntu_oraclejava'&gt;Ubuntu 下安装oracle官方Java&lt;/h1&gt;

&lt;p&gt;其实可能没必要。因为Java从7开始和openjdk的架构都很相似了。官方支持的openjdk完全可以完成我们需要的Java任务。本来我是要安装web Java。因此搜寻了一下。 可以参考&lt;a href='http://www.webupd8.org/2012/01/install-oracle-java-jdk-7-in-ubuntu-via.html'&gt;这篇文章&lt;/a&gt;。 很简单，通过ppa的方式添加repo，然后用apt-get安装。&lt;/p&gt;</description>
                <link>http://dbkaiser.github.io/Linux/2013/08/10/ubuntumplayeranyconnectvmware</link>
                <guid>http://dbkaiser.github.io/Linux/2013/08/10/ubuntumplayeranyconnectvmware</guid>
                <pubDate>2013-08-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jekyll Introduction</title>
                <description>&lt;p&gt;This Jekyll introduction will outline specifically what Jekyll is and why you would want to use it. Directly following the intro we&amp;#8217;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id='overview'&gt;Overview&lt;/h2&gt;

&lt;h3 id='what_is_jekyll'&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;#8220;a simple, blog aware, static site generator&amp;#8221;.&lt;/p&gt;

&lt;h3 id='examples'&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href='https://github.com/mojombo/jekyll/wiki/Sites'&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id='what_does_jekyll_do'&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system. Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder. The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id='jekyll_is_not_blogging_software'&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements. This is a common source of confusion when getting started. Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id='why_should_i_care'&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient. The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server. Traditional dynamic blogs like Wordpress require a database and server-side code. Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;

&lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;

&lt;li&gt;No internet connection required.&lt;/li&gt;

&lt;li&gt;Ability to publish via git.&lt;/li&gt;

&lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;

&lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;

&lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id='how_jekyll_works'&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples. This information is not intended to specifically teach you how to do anything, rather it is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id='initial_setup'&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href='/index.html#start-now'&gt;installing jekyll&lt;/a&gt; you&amp;#8217;ll need to format your website directory in a way jekyll expects. Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id='the_jekyll_application_base_format'&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;Stores configuration data.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;This folder is for partial views.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;This folder is for the main templates your content will be inserted into. You can have different layouts for different pages or page sections.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;This folder contains your dynamic content/posts. the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;This folder is not part of the standard jekyll structure. The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory. Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href='https://github.com/mojombo/jekyll/wiki/Usage'&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id='jekyll_configuration'&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Configuration'&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='content_in_jekyll'&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page. These content &amp;#8220;objects&amp;#8221; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id='posts_and_pages'&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax. Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id='working_with_posts'&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file. Additionally, each file must have &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt; prepended to its content. YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy. Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;Posts can have tags associated with them as part of their meta-data. Tags may be placed on posts by providing them in the post&amp;#8217;s YAML front matter. You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;Posts may be categorized by providing one or more categories in the YAML front matter. Categories offer more significance over tags in that they can be reflected in the URL path to the given post. Note categories in Jekyll work in a specific way. If you define more than one category you are defining a category hierarchy &amp;#8220;set&amp;#8221;. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &amp;#8220;lessons/beginner&amp;#8221;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll. You won&amp;#8217;t find &amp;#8220;lessons&amp;#8221; and &amp;#8220;beginner&amp;#8221; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id='working_with_pages'&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;In order to register as a Jekyll page the file must contain &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;YAML Front-Matter&lt;/a&gt;. Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;If pages are defined in sub-directories, the path to the page will be reflected in the url. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;Generating a sitemap is good practice for SEO.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='templates_in_jekyll'&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#8217;s or post&amp;#8217;s content. All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;. The site variable holds all accessible content and metadata relative to the site. The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;Templates should be coded in HTML and contain YAML Front Matter. All templates can contain Liquid code to work with your site&amp;#8217;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;. The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined. Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id='subtemplates'&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they define another &amp;#8220;root&amp;#8221; layout/template within their YAML Front Matter. This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id='includes'&gt;Includes&lt;/h3&gt;

&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder. Includes are NOT templates, rather they are just code snippets that get included into templates. In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id='using_liquid_for_templating'&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll. This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id='what_is_liquid'&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href='https://github.com/Shopify/liquid'&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href='http://shopify.com'&gt;Shopify&lt;/a&gt;. Liquid is designed for end-users to be able to execute logic within template files without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with your site and post/page data.&lt;/p&gt;

&lt;h3 id='why_do_we_have_to_use_liquid'&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href='http://pages.github.com/'&gt;GitHub Pages&lt;/a&gt;. GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id='liquid_is_not_programmerfriendly'&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code. The point being you can&amp;#8217;t do jackshit in liquid that hasn&amp;#8217;t been allowed explicitly by the implementation. What&amp;#8217;s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#8217;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;My personal stance is to not invest time trying to hack liquid. It&amp;#8217;s really unnecessary &lt;em&gt;from a programmer&amp;#8217;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code) you are better off sticking with ruby. Toward that end I&amp;#8217;ve built &lt;a href='http://github.com/plusjade/mustache-with-jekyll'&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='static_assets'&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages. That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id='how_jekyll_parses_files'&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;This is done with textile or markdown.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt; &lt;br /&gt;These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax. Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id='formatting_files_for_parsing'&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#8217;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;. Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty. This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block. The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here: &lt;a href='https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter'&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='defining_layouts_for_posts_and_templates_parsing'&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into. If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt; That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#8217;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id='how_jekyll_generates_the_final_static_files'&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#8217;s job is to generate a static representation of your website. The following is an outline of how that&amp;#8217;s done:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata. At this stage your site is one big computed ruby object.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s). Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;#8220;liquified&amp;#8221;. &lt;br /&gt;&lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;Finally the liquid templates are &amp;#8220;rendered&amp;#8221;, thereby processing any liquid syntax provided in the templates and saving the final, static representation of the file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;Because Jekyll computes the entire site in one fell swoop, each template is given access to a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#8217;ll iterate through and format using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;

&lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap. You can also read the original documentation here: &lt;a href='https://github.com/mojombo/jekyll/wiki/Template-Data'&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='conclusion'&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does. As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id='next_steps'&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href='' /&gt; or jump right into &lt;a href=''&gt;Usage&lt;/a&gt; if you&amp;#8217;d like.&lt;/p&gt;</description>
                <link>http://dbkaiser.github.io/lessons/2011/12/29/jekyll-introduction</link>
                <guid>http://dbkaiser.github.io/lessons/2011/12/29/jekyll-introduction</guid>
                <pubDate>2011-12-29T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
